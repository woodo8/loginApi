import { ClientContext } from "../ClientContext";
import { DiagnosticNodeInternal } from "../diagnostics/DiagnosticNodeInternal";
import { FeedOptions, PartitionedQueryExecutionInfo, QueryRange, Response } from "../request";
import { ExecutionContext } from "./ExecutionContext";
/** @hidden */
export declare enum HybridQueryExecutionContextBaseStates {
    uninitialized = "uninitialized",
    initialized = "initialized",
    draining = "draining",
    done = "done"
}
export declare class HybridQueryExecutionContext implements ExecutionContext {
    private clientContext;
    private collectionLink;
    private options;
    private partitionedQueryExecutionInfo;
    private correlatedActivityId;
    private allPartitionsRanges;
    private globalStatisticsExecutionContext;
    private componentsExecutionContext;
    private pageSize;
    private state;
    private globalStatisticsAggregator;
    private emitRawOrderByPayload;
    private buffer;
    private DEFAULT_PAGE_SIZE;
    private TOTAL_WORD_COUNT_PLACEHOLDER;
    private HIT_COUNTS_ARRAY_PLACEHOLDER;
    private TOTAL_DOCUMENT_COUNT_PLACEHOLDER;
    private RRF_CONSTANT;
    private logger;
    constructor(clientContext: ClientContext, collectionLink: string, options: FeedOptions, partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo, correlatedActivityId: string, allPartitionsRanges: QueryRange[]);
    nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>>;
    hasMoreResults(): boolean;
    fetchMore(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>>;
    private fetchMoreInternal;
    private initialize;
    private executeComponentQueries;
    private applySkipAndTakeToBuffer;
    private drain;
    private drainOne;
    private done;
    private sortHybridSearchResultByRRFScore;
    private drainSingleComponent;
    private createComponentExecutionContexts;
    private processComponentQueries;
    private replacePlaceholdersWorkaroud;
}
//# sourceMappingURL=hybridQueryExecutionContext.d.ts.map